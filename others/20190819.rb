MAX = 10000

l = gets.to_i
# dp[i][j][k]:= 下から数えてi桁(0-indexed)までみた時（実際は上から見ていく）、
#   j: そこまでLと一致していたら1, 何を入れてもL以下が成立するなら0（通称一致フラグ）
#   k: これまでにいくつの1が立ったか
dp = Array.new(MAX) { Array.new(2) { Array.new(3, 0) } }
dp[-1][1][0] = 1

(MAX - 2).downto(0) do |i|
  3.times do |k|
    if l[i] == 0 # 0しか入れられない
      dp[i][1][k] += dp[i + 1][1][k]
      dp[i][0][k] += dp[i + 1][0][k]
      next if k == 2
      # 一致フラグが立ってなければ、l[i]が0でも1を
      # 入れられる。
      dp[i][0][k + 1] += dp[i + 1][0][k]
    else
      dp[i][0][k] += dp[i + 1][1][k]
      dp[i][0][k] += dp[i + 1][0][k]
      next if k == 2
      dp[i][1][k + 1] += dp[i + 1][1][k]
      dp[i][0][k + 1] += dp[i + 1][0][k]
    end
  end
end
p dp[0][1][2] + dp[0][0][2]

__END__
【桁DPの例題】出典: フレンズ
整数L(3 <= L <= 10^18)が与えられる。
L以下の正整数のうち、二進数表記したとき1が立っている
bit数が2であるものの個数を求めよ。
